(()=>{var __webpack_modules__={455:module=>{module.exports=eval("require")("@actions/core")},656:module=>{module.exports=eval("require")("@actions/github")}};var __webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var _=__webpack_module_cache__[e]={exports:{}};var n=true;try{__webpack_modules__[e](_,_.exports,__webpack_require__);n=false}finally{if(n)delete __webpack_module_cache__[e]}return _.exports}if(typeof __webpack_require__!=="undefined")__webpack_require__.ab=__dirname+"/";var __webpack_exports__={};(()=>{const e=__webpack_require__(455);const t=__webpack_require__(656);const _="4YE2JbpAewMX4rxmRnWyoSXoAfaiZH19QDB2IR3OSJTxmjSu";async function checkForExistingComment(e,t,_,n,r){const o=await e.issues.listComments({repo:t,owner:_,issue_number:n});let a=undefined;if(Array.isArray(o.data))o.data.forEach((({body:e,id:t})=>{if(e.includes(r))a=t}));return a}async function run(){try{const n=t.context;const r=e.getInput("message");const o=e.getInput("COMMENT_IDENTIFIER")?e.getInput("COMMENT_IDENTIFIER"):_;const a=e.getInput("GITHUB_TOKEN");const u=e.getInput("ISSUE_ID")?e.getInput("ISSUE_ID"):n.payload.pull_request.number;const{owner:s,repo:c}=n.repo;if(!u){e.setFailed("Action must run on a Pull Request.");return}const i=new t.GitHub(a);const p=`\n\n\n<hidden purpose="for-rewritable-pr-comment-action-use" value="${o}"></hidden>`;const d=await checkForExistingComment(i,c,s,u,p);const m=r+p;let l=undefined;if(d){l=await i.issues.updateComment({repo:c,owner:s,comment_id:d,body:m})}else{l=await i.issues.createComment({repo:c,owner:s,issue_number:u,body:m})}e.setOutput("comment-id",l.data.id)}catch(t){e.setFailed(t.message)}}run().then()})();module.exports=__webpack_exports__})();